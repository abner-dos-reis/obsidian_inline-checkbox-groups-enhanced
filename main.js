/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => InlineCheckboxGroupPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_view = require("@codemirror/view");
var DEFAULT_SETTINGS = {
  separator: "|",
  crossOutWhenAllChecked: true
};
var InlineCheckboxGroupPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerMarkdownPostProcessor((element, context) => {
      // Search common block-level elements (paragraphs, list items, blockquotes, divs, callouts, etc.)
      const candidates = element.querySelectorAll("p, li, blockquote, div, .callout-content");
      candidates.forEach((el) => {
        const text = el.textContent;
        if (text == null ? void 0 : text.match(/\[ ?\]|\[x\]/i)) {
          this.renderCheckboxGroup(el, context);
        }
      });
    });
    this.registerEditorExtension([
      import_view.EditorView.updateListener.of((update) => {
        if (update.docChanged) {
          this.handleEditorUpdate(update);
        }
      })
    ]);
    this.addSettingTab(new InlineCheckboxGroupSettingTab(this.app, this));
  }
  onunload() {
    if (this.observer) {
      this.observer.disconnect();
    }
  }
  updateStrikethrough(paragraph) {
    if (!this.settings.crossOutWhenAllChecked)
      return;
    const containers = paragraph.querySelectorAll(".checkbox-group-container");
    const checkboxes = paragraph.querySelectorAll('input[type="checkbox"]');
    const allChecked = Array.from(checkboxes).every((cb) => cb.checked);
    if (allChecked) {
      paragraph.classList.add("checkbox-crossed-out");
    } else {
      paragraph.classList.remove("checkbox-crossed-out");
    }
    containers.forEach((container) => {
      if (allChecked) {
        container.classList.add("checkbox-crossed-out");
      } else {
        container.classList.remove("checkbox-crossed-out");
      }
    });
  }
  async handleCheckboxChange(checkbox) {
    var _a, _b;
    const container = checkbox.closest(".checkbox-group-container");
    if (!container)
      return;
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!view)
      return;
    let paragraph = container.closest("[data-line-number]");
    if (!paragraph)
      paragraph = container.closest("p, li");
    if (!paragraph)
      return;
    const lineNumber = parseInt(paragraph.getAttribute("data-line-number") || "-1");
    const checkboxIndex = parseInt(container.getAttribute("data-checkbox-index") || "-1");
    if (lineNumber >= 0 && checkboxIndex >= 0) {
      const editor = view.editor;
      const line = editor.getLine(lineNumber);
      
      // Parse checkboxes using regex - find all checkbox patterns
      const checkboxRegex = /\[[\sx]?\]/gi;
      const checkboxMatches = line.match(checkboxRegex) || [];
      
      // Split line by checkboxes and reconstruct items
      const parts = line.split(checkboxRegex);
      const items = [];
      
      // Reconstruct items by combining checkbox pattern with following text
      for (let i = 0; i < checkboxMatches.length; i++) {
        const checkboxPart = checkboxMatches[i];
        const textPart = parts[i + 1] || "";
        
        // Extract text until next checkbox or end
        const nextCheckboxIndex = textPart.search(/\[[\sx]?\]/);
        let content = nextCheckboxIndex >= 0 ? textPart.substring(0, nextCheckboxIndex) : textPart;
        content = content.trim();
        
        items.push(`${checkboxPart}${content ? ' ' + content : ''}`);
        
        // Update parts array to remove consumed text
        if (nextCheckboxIndex >= 0) {
          parts[i + 1] = textPart.substring(nextCheckboxIndex);
        }
      }
      
      // Fallback to original separator logic if needed
      if (items.length === 0 && line.includes(this.settings.separator)) {
        const fallbackItems = line.split(this.settings.separator).map((item) => item.trim());
        items.push(...fallbackItems);
      }
      
      if (checkboxIndex < items.length) {
        const currentItem = items[checkboxIndex];
        if (currentItem.match(/^(?:-\s*)?\[[\sx]?\]/i)) {
          const prefix = ((_a = currentItem.match(/^[\s-]*/)) == null ? void 0 : _a[0]) || "";
          const content = currentItem.replace(/^(?:-\s*)?\[[\sx]?\]/, "").trim();
          const newCheckboxState = checkbox.checked ? "[x]" : "[ ]";
          items[checkboxIndex] = `${newCheckboxState}${content ? ' ' + content : ''}`;
          
          // Reconstruct line preserving original spacing and structure
          // Find the leading text before the first checkbox
          const leadingText = paragraph.getAttribute("data-leading-text") || "";
          const firstCheckboxPos = line.indexOf('[');
          const actualLeadingText = firstCheckboxPos > 0 ? line.substring(0, firstCheckboxPos).trim() : leadingText;
          
          // Join items with a single space
          let newLine = items.join(' ');
          
          // Add leading text if it exists
          if (actualLeadingText) {
            newLine = `${actualLeadingText} ${newLine}`;
          }

          editor.setLine(lineNumber, newLine);
          const file = view.file;
          if (file) {
            await this.app.vault.modify(file, editor.getValue());
            (_b = view.previewMode) == null ? void 0 : _b.rerender(true);
          }
          this.updateStrikethrough(paragraph);
        }
      }
    }
  }
  handleEditorUpdate(update) {
    const doc = update.state.doc;
    for (let i = 1; i <= doc.lines; i++) {
      const line = doc.line(i);
      const text = line.text;
      if (text.match(/(?:-\s*)?\[\s*[x ]?\s*\]/i)) {
        // Check for multiple checkboxes in the line
        const checkboxMatches = text.match(/\[[\sx]?\]/gi);
        if (checkboxMatches && checkboxMatches.length > 1) {
          // Multiple checkboxes found, no need for separator
          return;
        } else {
          // Single checkbox or fallback to separator logic
          const items = text.includes(this.settings.separator) ? text.split(this.settings.separator) : [text];
          items.forEach((item, index) => {
            const trimmedItem = item.trim();
            if (trimmedItem.match(/^(?:-\s*)?\[\s*[x ]?\s*\]/i)) {
              return;
            }
          });
        }
      }
    }
  }
  renderCheckboxGroup(element, context) {
    // Get only the direct text content, not from child elements
    let text = "";
    for (let node of element.childNodes) {
      if (node.nodeType === Node.TEXT_NODE) {
        text += node.nodeValue || "";
      } else if (node.nodeType === Node.ELEMENT_NODE) {
        // Only include text from inline elements, not block elements like nested lists
        const tagName = node.tagName?.toLowerCase();
        if (tagName && !['ul', 'ol', 'li', 'div', 'blockquote'].includes(tagName)) {
          text += node.textContent || "";
        }
      }
    }
    
    // Split by checkboxes pattern to find individual checkbox items
    const checkboxRegex = /\[[\sx]?\]/gi;
    
    // Find all checkbox matches
    const checkboxMatches = text.match(checkboxRegex) || [];
    const items = [];
    
    // Capture any leading text that comes before the first checkbox (e.g. "Curso ", "- ", "> ")
    let leadingText = "";
    const firstCheckboxIndex = text.search(checkboxRegex);
    if (firstCheckboxIndex > 0) {
      leadingText = text.substring(0, firstCheckboxIndex).trim();
    }
    
    // Split text by checkbox patterns
    const parts = text.split(checkboxRegex);
    
    // Reconstruct items by combining checkbox pattern with following text
    for (let i = 0; i < checkboxMatches.length; i++) {
      const checkboxPart = checkboxMatches[i];
      const textPart = parts[i + 1] || "";
      
      // Extract text until next checkbox or end
      const nextCheckboxIndex = textPart.search(/\[[\sx]?\]/);
      let content = nextCheckboxIndex >= 0 ? textPart.substring(0, nextCheckboxIndex) : textPart;
      content = content.trim();
      
      items.push(`${checkboxPart}${content ? ' ' + content : ''}`);
      
      // Update parts array to remove consumed text
      if (nextCheckboxIndex >= 0) {
        parts[i + 1] = textPart.substring(nextCheckboxIndex);
      }
    }
    
    // Fallback to original logic if no multiple checkboxes found
    if (items.length === 0 && text.includes(this.settings.separator)) {
      const fallbackItems = text.split(this.settings.separator).map((item) => item.trim());
      items.push(...fallbackItems);
    }
    
    // If still no items, try to parse as single checkbox
    if (items.length === 0 && checkboxMatches.length > 0) {
      items.push(text.trim());
    }
    
    // Instead of emptying the element (which breaks surrounding list/callout structure),
    // walk the element's text nodes and replace checkbox tokens with interactive controls.
    element.setAttribute("data-original-text", text.trim());
    // Save the detected leading text so we can preserve it when updating the editor
    element.setAttribute("data-leading-text", leadingText);
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (view) {
      const editor = view.editor;
      const lines = editor.getValue().split("\n");
      const expectedCheckboxCount = (text.match(/\[[\sx]?\]/g) || []).length || (items.length || 0);

      // Normalization to compare preview text with editor lines while
      // ignoring wiki-links, formatting markers, list/callout prefixes, and extra whitespace.
      const normalize = (s) => {
        return (s || "")
          .replace(/\[\[([^\]|]+)\|?([^\]]+)?\]\]/g, (_, a, b) => (b || a))
          .replace(/\[x\]|\[ \]|\[\s\]/gi, "")
          .replace(/[\*_~`]/g, "")
          .replace(/(^|\s)[>#]+/g, " ")
          .replace(/(^|\s)\-\s?/g, " ")
          .replace(/(^|\s)\+\s?/g, " ")
          .replace(/(^|\s)\d+\.\s?/g, " ")
          .replace(/\s+/g, " ")
          .trim()
          .toLowerCase();
      };

      const normalizedPreview = normalize(text);

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const lineCheckboxCount = (line.match(/\[[\sx]?\]/g) || []).length;
        if (lineCheckboxCount !== expectedCheckboxCount)
          continue;

        const normalizedLine = normalize(line);
        const matchesNormalized = normalizedPreview && (normalizedLine.includes(normalizedPreview) || normalizedPreview.includes(normalizedLine));
        const hasLeading = leadingText ? normalize(line).includes(normalize(leadingText)) : true;

        if ((matchesNormalized || hasLeading) && line.match(/\[[\sx]?\]/)) {
          const existingElements = document.querySelectorAll(`[data-line-number="${i}"]`);
          if (existingElements.length === 0 || Array.from(existingElements).some((el) => el === element)) {
            element.setAttribute("data-line-number", i.toString());
            break;
          }
        }
      }
    }
    // Debug: log render start
    try {
      console.debug && console.debug("Inline-Checkbox-Groups: renderCheckboxGroup start", { text: text, itemsLength: items.length });
    } catch (e) {
    }

    // Replace checkbox tokens inside text nodes while preserving DOM structure.
    let itemIndex = 0;
    const allChecked = items.every((item) => item.match(/\[x\]/i));

    const processNode = (node) => {
      if (!node)
        return;
      if (node.nodeType === Node.TEXT_NODE) {
        const txt = node.nodeValue || "";
        const tempRegex = /\[[\sx]?\]/gi;
        if (tempRegex.test(txt)) {
          // Reset regex and split by checkbox patterns
          const checkboxPattern = /\[[\sx]?\]/gi;
          const matches = txt.match(checkboxPattern) || [];
          const parts = txt.split(checkboxPattern);
          const frag = document.createDocumentFragment();
          
          // Add leading text before first checkbox
          if (parts[0]) {
            frag.appendChild(document.createTextNode(parts[0]));
          }
          
          // Process each checkbox
          for (let i = 0; i < matches.length; i++) {
            const item = items[itemIndex] || matches[i];
            const container = document.createElement("span");
            container.className = "checkbox-group-container";
            container.setAttribute("data-checkbox-index", String(itemIndex));
            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.className = "task-list-item-checkbox";
            checkbox.checked = /\[x\]/i.test(matches[i]);
            this.registerDomEvent(checkbox, "change", () => this.handleCheckboxChange(checkbox));
            
            // Only add span if the item has text content beyond the checkbox
            const itemText = item.replace(/\[[\sx]?\]/i, "").trim();
            if (itemText) {
              const span = document.createElement("span");
              span.textContent = itemText;
              if (allChecked && this.settings.crossOutWhenAllChecked) {
                container.classList.add("checkbox-crossed-out");
              }
              container.appendChild(checkbox);
              container.appendChild(span);
            } else {
              if (allChecked && this.settings.crossOutWhenAllChecked) {
                container.classList.add("checkbox-crossed-out");
              }
              container.appendChild(checkbox);
            }
            
            frag.appendChild(container);
            itemIndex++;
          }
          
          // Add any remaining text after last checkbox (only from same text node)
          const lastPartIndex = matches.length;
          if (parts[lastPartIndex]) {
            frag.appendChild(document.createTextNode(parts[lastPartIndex]));
          }
          
          if (node.parentNode) {
            node.parentNode.replaceChild(frag, node);
          }
        }
      } else if (node.nodeType === Node.ELEMENT_NODE) {
        // Don't process nodes we've injected or list markers
        if (node.classList && node.classList.contains("checkbox-group-container"))
          return;
        if (node.classList && node.classList.contains("list-bullet"))
          return;
        const children = Array.from(node.childNodes);
        for (let c of children)
          processNode(c);
      }
    };

    // Start processing from the element's child nodes
    const children = Array.from(element.childNodes);
    for (let c of children)
      processNode(c);

    try {
      console.debug && console.debug("Inline-Checkbox-Groups: injected items", itemIndex, "of", items.length);
    } catch (e) {
    }

    // If we didn't inject all checkboxes, try more aggressive tree walking
    if (itemIndex < items.length) {
      const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null, false);
      let n2;
      while (n2 = walker.nextNode()) {
        if ((n2.nodeValue || '').match(/\[[\sx]?\]/)) {
          processNode(n2);
        }
      }
      try {
        console.debug && console.debug("Inline-Checkbox-Groups: after permissive pass injected items", itemIndex);
      } catch (e) {
      }
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var InlineCheckboxGroupSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Separator").setDesc("Character used to separate checkboxes in a group").addText((text) => text.setPlaceholder("|").setValue(this.plugin.settings.separator).onChange(async (value) => {
      this.plugin.settings.separator = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Cross out completed items").setDesc("Cross out text when all checkboxes in a group are checked").addToggle((toggle) => toggle.setValue(this.plugin.settings.crossOutWhenAllChecked).onChange(async (value) => {
      var _a, _b;
      this.plugin.settings.crossOutWhenAllChecked = value;
      await this.plugin.saveSettings();
      (_b = (_a = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView)) == null ? void 0 : _a.previewMode) == null ? void 0 : _b.rerender(true);
    }));
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgUGx1Z2luLCBNYXJrZG93blZpZXcsIEVkaXRvciwgQXBwLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgRWRpdG9yVmlldywgVmlld1VwZGF0ZSB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuXG5pbnRlcmZhY2UgSW5saW5lQ2hlY2tib3hHcm91cFNldHRpbmdzIHtcbiAgICBzZXBhcmF0b3I6IHN0cmluZztcbiAgICBjcm9zc091dFdoZW5BbGxDaGVja2VkOiBib29sZWFuO1xufVxuXG5jb25zdCBERUZBVUxUX1NFVFRJTkdTOiBJbmxpbmVDaGVja2JveEdyb3VwU2V0dGluZ3MgPSB7XG4gICAgc2VwYXJhdG9yOiAnfCcsXG4gICAgY3Jvc3NPdXRXaGVuQWxsQ2hlY2tlZDogdHJ1ZVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5saW5lQ2hlY2tib3hHcm91cFBsdWdpbiBleHRlbmRzIFBsdWdpbiB7XG4gICAgc2V0dGluZ3M6IElubGluZUNoZWNrYm94R3JvdXBTZXR0aW5ncztcbiAgICBwcml2YXRlIG9ic2VydmVyOiBNdXRhdGlvbk9ic2VydmVyO1xuXG4gICAgYXN5bmMgb25sb2FkKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xuXG4gICAgICAgIHRoaXMucmVnaXN0ZXJNYXJrZG93blBvc3RQcm9jZXNzb3IoKGVsZW1lbnQsIGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFncmFwaHMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3AnKTtcbiAgICAgICAgICAgIHBhcmFncmFwaHMuZm9yRWFjaChwYXJhID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gcGFyYS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICBpZiAodGV4dD8ubWF0Y2goL1xcWyA/XFxdfFxcW3hcXF0vaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJDaGVja2JveEdyb3VwKHBhcmEsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnJlZ2lzdGVyRWRpdG9yRXh0ZW5zaW9uKFtcbiAgICAgICAgICAgIEVkaXRvclZpZXcudXBkYXRlTGlzdGVuZXIub2YoKHVwZGF0ZTogVmlld1VwZGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUVkaXRvclVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIF0pO1xuXG4gICAgICAgIHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgSW5saW5lQ2hlY2tib3hHcm91cFNldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpKTtcbiAgICB9XG5cbiAgICBvbnVubG9hZCgpIHtcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVTdHJpa2V0aHJvdWdoKHBhcmFncmFwaDogSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLmNyb3NzT3V0V2hlbkFsbENoZWNrZWQpIHJldHVybjtcblxuICAgICAgICBjb25zdCBjb250YWluZXJzID0gcGFyYWdyYXBoLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jaGVja2JveC1ncm91cC1jb250YWluZXInKTtcbiAgICAgICAgY29uc3QgY2hlY2tib3hlcyA9IHBhcmFncmFwaC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0nKSBhcyBOb2RlTGlzdE9mPEhUTUxJbnB1dEVsZW1lbnQ+O1xuICAgICAgICBjb25zdCBhbGxDaGVja2VkID0gQXJyYXkuZnJvbShjaGVja2JveGVzKS5ldmVyeShjYiA9PiBjYi5jaGVja2VkKTtcblxuICAgICAgICAvLyBBcHBseSBzdHJpa2V0aHJvdWdoIHRvIHRoZSBlbnRpcmUgcGFyYWdyYXBoIGlmIGFsbCBjaGVja2JveGVzIGFyZSBjaGVja2VkXG4gICAgICAgIGlmIChhbGxDaGVja2VkKSB7XG4gICAgICAgICAgICBwYXJhZ3JhcGguY2xhc3NMaXN0LmFkZCgnY2hlY2tib3gtY3Jvc3NlZC1vdXQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFncmFwaC5jbGFzc0xpc3QucmVtb3ZlKCdjaGVja2JveC1jcm9zc2VkLW91dCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWxzbyB1cGRhdGUgaW5kaXZpZHVhbCBjb250YWluZXJzXG4gICAgICAgIGNvbnRhaW5lcnMuZm9yRWFjaChjb250YWluZXIgPT4ge1xuICAgICAgICAgICAgaWYgKGFsbENoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnY2hlY2tib3gtY3Jvc3NlZC1vdXQnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoJ2NoZWNrYm94LWNyb3NzZWQtb3V0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgaGFuZGxlQ2hlY2tib3hDaGFuZ2UoY2hlY2tib3g6IEhUTUxJbnB1dEVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gY2hlY2tib3guY2xvc2VzdCgnLmNoZWNrYm94LWdyb3VwLWNvbnRhaW5lcicpO1xuICAgICAgICBpZiAoIWNvbnRhaW5lcikgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IHZpZXcgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlVmlld09mVHlwZShNYXJrZG93blZpZXcpO1xuICAgICAgICBpZiAoIXZpZXcpIHJldHVybjtcblxuICAgICAgICBjb25zdCBwYXJhZ3JhcGggPSBjb250YWluZXIuY2xvc2VzdCgncCcpO1xuICAgICAgICBpZiAoIXBhcmFncmFwaCkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IGxpbmVOdW1iZXIgPSBwYXJzZUludChwYXJhZ3JhcGguZ2V0QXR0cmlidXRlKCdkYXRhLWxpbmUtbnVtYmVyJykgfHwgJy0xJyk7XG4gICAgICAgIGNvbnN0IGNoZWNrYm94SW5kZXggPSBwYXJzZUludChjb250YWluZXIuZ2V0QXR0cmlidXRlKCdkYXRhLWNoZWNrYm94LWluZGV4JykgfHwgJy0xJyk7XG5cbiAgICAgICAgaWYgKGxpbmVOdW1iZXIgPj0gMCAmJiBjaGVja2JveEluZGV4ID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGVkaXRvciA9IHZpZXcuZWRpdG9yO1xuICAgICAgICAgICAgY29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGxpbmVOdW1iZXIpO1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBsaW5lLnNwbGl0KHRoaXMuc2V0dGluZ3Muc2VwYXJhdG9yKS5tYXAoaXRlbSA9PiBpdGVtLnRyaW0oKSk7XG5cbiAgICAgICAgICAgIGlmIChjaGVja2JveEluZGV4IDwgaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEl0ZW0gPSBpdGVtc1tjaGVja2JveEluZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEl0ZW0ubWF0Y2goL14oPzotXFxzKik/XFxbW1xcc3hdP1xcXS9pKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXggPSBjdXJyZW50SXRlbS5tYXRjaCgvXltcXHMtXSovKT8uWzBdIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gY3VycmVudEl0ZW0ucmVwbGFjZSgvXig/Oi1cXHMqKT9cXFtbXFxzeF0/XFxdLywgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NoZWNrYm94U3RhdGUgPSBjaGVja2JveC5jaGVja2VkID8gJ1t4XScgOiAnWyBdJztcbiAgICAgICAgICAgICAgICAgICAgaXRlbXNbY2hlY2tib3hJbmRleF0gPSBgJHtwcmVmaXh9JHtuZXdDaGVja2JveFN0YXRlfSAke2NvbnRlbnR9YDtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xpbmUgPSBpdGVtcy5qb2luKGAke3RoaXMuc2V0dGluZ3Muc2VwYXJhdG9yfWApO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnNldExpbmUobGluZU51bWJlciwgbmV3TGluZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGUgPSB2aWV3LmZpbGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5tb2RpZnkoZmlsZSwgZWRpdG9yLmdldFZhbHVlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5wcmV2aWV3TW9kZT8ucmVyZW5kZXIodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0cmlrZXRocm91Z2gocGFyYWdyYXBoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGhhbmRsZUVkaXRvclVwZGF0ZSh1cGRhdGU6IFZpZXdVcGRhdGUpIHtcbiAgICAgICAgY29uc3QgZG9jID0gdXBkYXRlLnN0YXRlLmRvYztcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gZG9jLmxpbmVzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBkb2MubGluZShpKTtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBsaW5lLnRleHQ7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh0ZXh0Lm1hdGNoKC8oPzotXFxzKik/XFxbXFxzKlt4IF0/XFxzKlxcXS9pKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gdGV4dC5pbmNsdWRlcyh0aGlzLnNldHRpbmdzLnNlcGFyYXRvcilcbiAgICAgICAgICAgICAgICAgICAgPyB0ZXh0LnNwbGl0KHRoaXMuc2V0dGluZ3Muc2VwYXJhdG9yKVxuICAgICAgICAgICAgICAgICAgICA6IFt0ZXh0XTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmltbWVkSXRlbSA9IGl0ZW0udHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJpbW1lZEl0ZW0ubWF0Y2goL14oPzotXFxzKik/XFxbXFxzKlt4IF0/XFxzKlxcXS9pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHJlbmRlckNoZWNrYm94R3JvdXAoZWxlbWVudDogSFRNTEVsZW1lbnQsIGNvbnRleHQ6IGFueSkge1xuICAgICAgICBjb25zdCB0ZXh0ID0gZWxlbWVudC50ZXh0Q29udGVudCB8fCAnJztcbiAgICAgICAgY29uc3QgaXRlbXMgPSB0ZXh0LmluY2x1ZGVzKHRoaXMuc2V0dGluZ3Muc2VwYXJhdG9yKSBcbiAgICAgICAgICAgID8gdGV4dC5zcGxpdCh0aGlzLnNldHRpbmdzLnNlcGFyYXRvcikubWFwKGl0ZW0gPT4gaXRlbS50cmltKCkpXG4gICAgICAgICAgICA6IFt0ZXh0LnRyaW0oKV07XG4gICAgICAgIFxuICAgICAgICBlbGVtZW50LmVtcHR5KCk7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLXRleHQnLCB0ZXh0LnRyaW0oKSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoTWFya2Rvd25WaWV3KTtcbiAgICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgICAgIGNvbnN0IGVkaXRvciA9IHZpZXcuZWRpdG9yO1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBlZGl0b3IuZ2V0VmFsdWUoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVzW2ldLnRyaW0oKSA9PT0gdGV4dC50cmltKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdFbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYHBbZGF0YS1saW5lLW51bWJlcj1cIiR7aX1cIl1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nRWxlbWVudHMubGVuZ3RoID09PSAwIHx8IEFycmF5LmZyb20oZXhpc3RpbmdFbGVtZW50cykuc29tZShlbCA9PiBlbCA9PT0gZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWxpbmUtbnVtYmVyJywgaS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYWxsQ2hlY2tlZCA9IGl0ZW1zLmV2ZXJ5KGl0ZW0gPT4gaXRlbS5tYXRjaCgvXFxbeFxcXS9pKSk7XG4gICAgICAgIGlmIChhbGxDaGVja2VkICYmIHRoaXMuc2V0dGluZ3MuY3Jvc3NPdXRXaGVuQWxsQ2hlY2tlZCkge1xuICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdjaGVja2JveC1jcm9zc2VkLW91dCcpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0ubWF0Y2goL1xcWyA/XFxdfFxcW3hcXF0vaSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBlbGVtZW50LmNyZWF0ZURpdih7XG4gICAgICAgICAgICAgICAgICAgIGNsczogJ2NoZWNrYm94LWdyb3VwLWNvbnRhaW5lcidcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKCdkYXRhLWNoZWNrYm94LWluZGV4JywgaW5kZXgudG9TdHJpbmcoKSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjaGVja2JveCA9IGNvbnRhaW5lci5jcmVhdGVFbCgnaW5wdXQnLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjaGVja2JveCcsXG4gICAgICAgICAgICAgICAgICAgIGNsczogJ3Rhc2stbGlzdC1pdGVtLWNoZWNrYm94J1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSBpdGVtLmluY2x1ZGVzKCdbeF0nKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVyRG9tRXZlbnQoY2hlY2tib3gsICdjaGFuZ2UnLCAoKSA9PiB0aGlzLmhhbmRsZUNoZWNrYm94Q2hhbmdlKGNoZWNrYm94KSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzcGFuID0gY29udGFpbmVyLmNyZWF0ZVNwYW4oe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBpdGVtLnJlcGxhY2UoL1xcWyA/XFxdfFxcW3hcXF0vLCAnJykudHJpbSgpXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMSAmJiBpbmRleCA8IGl0ZW1zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLmNyZWF0ZVNwYW4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogYCR7dGhpcy5zZXR0aW5ncy5zZXBhcmF0b3J9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsczogJ2NoZWNrYm94LWdyb3VwLXNlcGFyYXRvcidcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGFsbENoZWNrZWQgJiYgdGhpcy5zZXR0aW5ncy5jcm9zc091dFdoZW5BbGxDaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdjaGVja2JveC1jcm9zc2VkLW91dCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgbG9hZFNldHRpbmdzKCkge1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKTtcbiAgICB9XG5cbiAgICBhc3luYyBzYXZlU2V0dGluZ3MoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG4gICAgfVxufVxuXG5jbGFzcyBJbmxpbmVDaGVja2JveEdyb3VwU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuICAgIHBsdWdpbjogSW5saW5lQ2hlY2tib3hHcm91cFBsdWdpbjtcblxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IElubGluZUNoZWNrYm94R3JvdXBQbHVnaW4pIHtcbiAgICAgICAgc3VwZXIoYXBwLCBwbHVnaW4pO1xuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgICB9XG5cbiAgICBkaXNwbGF5KCk6IHZvaWQge1xuICAgICAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuICAgICAgICBjb250YWluZXJFbC5lbXB0eSgpO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1NlcGFyYXRvcicpXG4gICAgICAgICAgICAuc2V0RGVzYygnQ2hhcmFjdGVyIHVzZWQgdG8gc2VwYXJhdGUgY2hlY2tib3hlcyBpbiBhIGdyb3VwJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignfCcpXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnNlcGFyYXRvcilcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnNlcGFyYXRvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnQ3Jvc3Mgb3V0IGNvbXBsZXRlZCBpdGVtcycpXG4gICAgICAgICAgICAuc2V0RGVzYygnQ3Jvc3Mgb3V0IHRleHQgd2hlbiBhbGwgY2hlY2tib3hlcyBpbiBhIGdyb3VwIGFyZSBjaGVja2VkJylcbiAgICAgICAgICAgIC5hZGRUb2dnbGUodG9nZ2xlID0+IHRvZ2dsZVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5jcm9zc091dFdoZW5BbGxDaGVja2VkKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuY3Jvc3NPdXRXaGVuQWxsQ2hlY2tlZCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoTWFya2Rvd25WaWV3KT8ucHJldmlld01vZGU/LnJlcmVuZGVyKHRydWUpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICB9XG59Il0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHNCQUE2RTtBQUM3RSxrQkFBdUM7QUFPdkMsSUFBTSxtQkFBZ0Q7QUFBQSxFQUNsRCxXQUFXO0FBQUEsRUFDWCx3QkFBd0I7QUFDNUI7QUFFQSxJQUFxQiw0QkFBckIsY0FBdUQsdUJBQU87QUFBQSxFQUkxRCxNQUFNLFNBQVM7QUFDWCxVQUFNLEtBQUssYUFBYTtBQUV4QixTQUFLLDhCQUE4QixDQUFDLFNBQVMsWUFBWTtBQUNyRCxZQUFNLGFBQWEsUUFBUSxpQkFBaUIsR0FBRztBQUMvQyxpQkFBVyxRQUFRLFVBQVE7QUFDdkIsY0FBTSxPQUFPLEtBQUs7QUFDbEIsWUFBSSw2QkFBTSxNQUFNLGtCQUFrQjtBQUM5QixlQUFLLG9CQUFvQixNQUFNLE9BQU87QUFBQSxRQUMxQztBQUFBLE1BQ0osQ0FBQztBQUFBLElBQ0wsQ0FBQztBQUVELFNBQUssd0JBQXdCO0FBQUEsTUFDekIsdUJBQVcsZUFBZSxHQUFHLENBQUMsV0FBdUI7QUFDakQsWUFBSSxPQUFPLFlBQVk7QUFDbkIsZUFBSyxtQkFB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
