/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => InlineCheckboxGroupPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_view = require("@codemirror/view");
var DEFAULT_SETTINGS = {
  separator: "|",
  crossOutWhenAllChecked: true
};
var InlineCheckboxGroupPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerMarkdownPostProcessor((element, context) => {
      // Search common block-level elements (paragraphs, list items, blockquotes, divs)
      const candidates = element.querySelectorAll("p, li, blockquote, div");
      candidates.forEach((el) => {
        const text = el.textContent;
        if (text == null ? void 0 : text.match(/\[ ?\]|\[x\]/i)) {
          this.renderCheckboxGroup(el, context);
        }
      });
    });
    this.registerEditorExtension([
      import_view.EditorView.updateListener.of((update) => {
        if (update.docChanged) {
          this.handleEditorUpdate(update);
        }
      })
    ]);
    this.addSettingTab(new InlineCheckboxGroupSettingTab(this.app, this));
  }
  onunload() {
    if (this.observer) {
      this.observer.disconnect();
    }
  }
  updateStrikethrough(paragraph) {
    if (!this.settings.crossOutWhenAllChecked)
      return;
    const containers = paragraph.querySelectorAll(".checkbox-group-container");
    const checkboxes = paragraph.querySelectorAll('input[type="checkbox"]');
    const allChecked = Array.from(checkboxes).every((cb) => cb.checked);
    if (allChecked) {
      paragraph.classList.add("checkbox-crossed-out");
    } else {
      paragraph.classList.remove("checkbox-crossed-out");
    }
    containers.forEach((container) => {
      if (allChecked) {
        container.classList.add("checkbox-crossed-out");
      } else {
        container.classList.remove("checkbox-crossed-out");
      }
    });
  }
  async handleCheckboxChange(checkbox) {
    var _a, _b;
    const container = checkbox.closest(".checkbox-group-container");
    if (!container)
      return;
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!view)
      return;
    let paragraph = container.closest("[data-line-number]");
    if (!paragraph)
      paragraph = container.closest("p");
    if (!paragraph)
      return;
    const lineNumber = parseInt(paragraph.getAttribute("data-line-number") || "-1");
    const checkboxIndex = parseInt(container.getAttribute("data-checkbox-index") || "-1");
    if (lineNumber >= 0 && checkboxIndex >= 0) {
      const editor = view.editor;
      const line = editor.getLine(lineNumber);
      
      // Parse checkboxes using regex instead of separator
      const checkboxRegex = /(\[[\sx]?\])/gi;
      const parts = line.split(checkboxRegex);
      const items = [];
      
      // Reconstruct items by combining checkbox pattern with following text
      for (let i = 0; i < parts.length; i++) {
        if (parts[i] && parts[i].match(checkboxRegex)) {
          const checkboxPart = parts[i];
          const textPart = parts[i + 1] || "";
          const nextCheckboxIndex = textPart.search(/\[[\sx]?\]/);
          let content = nextCheckboxIndex >= 0 ? textPart.substring(0, nextCheckboxIndex) : textPart;
          content = content.trim();
          items.push(`${checkboxPart} ${content}`.trim());
          if (nextCheckboxIndex >= 0) {
            parts[i + 1] = textPart.substring(nextCheckboxIndex);
          } else {
            i++;
          }
        }
      }
      
      // Fallback to original separator logic if needed
      if (items.length <= 1) {
        const fallbackItems = line.includes(this.settings.separator) ? line.split(this.settings.separator).map((item) => item.trim()) : [line.trim()];
        items.length = 0;
        items.push(...fallbackItems);
      }
      
      if (checkboxIndex < items.length) {
        const currentItem = items[checkboxIndex];
        if (currentItem.match(/^(?:-\s*)?\[[\sx]?\]/i)) {
          const prefix = ((_a = currentItem.match(/^[\s-]*/)) == null ? void 0 : _a[0]) || "";
          const content = currentItem.replace(/^(?:-\s*)?\[[\sx]?\]/, "").trim();
          const newCheckboxState = checkbox.checked ? "[x]" : "[ ]";
          items[checkboxIndex] = `${prefix}${newCheckboxState} ${content}`;
          
          // Reconstruct line preserving original spacing and structure
          let newLine = items.join(" ");
          // Preserve any leading text that was present before the first checkbox
          // but avoid duplicating it when the reconstructed content already contains it
          const leadingText = paragraph.getAttribute("data-leading-text") || "";
          if (leadingText) {
            const nl = newLine.trim();
            // Find any prefix before the first checkbox in the reconstructed line
            const firstBracket = nl.indexOf("[");
            const prefixInNewLine = firstBracket > 0 ? nl.substring(0, firstBracket).trim() : "";
            if (!prefixInNewLine || prefixInNewLine !== leadingText) {
              // Only prefix if the leadingText is not already present before the first checkbox
              newLine = `${leadingText} ${newLine}`.trim();
            }
          }

          editor.setLine(lineNumber, newLine);
          const file = view.file;
          if (file) {
            await this.app.vault.modify(file, editor.getValue());
            (_b = view.previewMode) == null ? void 0 : _b.rerender(true);
          }
          this.updateStrikethrough(paragraph);
        }
      }
    }
  }
  handleEditorUpdate(update) {
    const doc = update.state.doc;
    for (let i = 1; i <= doc.lines; i++) {
      const line = doc.line(i);
      const text = line.text;
      if (text.match(/(?:-\s*)?\[\s*[x ]?\s*\]/i)) {
        // Check for multiple checkboxes in the line
        const checkboxMatches = text.match(/\[[\sx]?\]/gi);
        if (checkboxMatches && checkboxMatches.length > 1) {
          // Multiple checkboxes found, no need for separator
          return;
        } else {
          // Single checkbox or fallback to separator logic
          const items = text.includes(this.settings.separator) ? text.split(this.settings.separator) : [text];
          items.forEach((item, index) => {
            const trimmedItem = item.trim();
            if (trimmedItem.match(/^(?:-\s*)?\[\s*[x ]?\s*\]/i)) {
              return;
            }
          });
        }
      }
    }
  }
  renderCheckboxGroup(element, context) {
    const text = element.textContent || "";
    // Collect direct text nodes (exclude nested child element text) to detect any leading label
    const directText = Array.from(element.childNodes).filter((n) => n.nodeType === Node.TEXT_NODE).map((n) => n.nodeValue || "").join("").trim();
    // Split by checkboxes pattern to find individual checkbox items
    const checkboxRegex = /(\[[\sx]?\])/gi;
    const parts = text.split(checkboxRegex);
    const items = [];
    
    // Capture any leading text that comes before the first checkbox from DIRECT text only
    let leadingText = "";
    if (directText) {
      const directParts = directText.split(checkboxRegex);
      if (directParts.length > 0 && !(directParts[0] || "").match(checkboxRegex) && (directParts[0] || "").trim() !== "") {
        leadingText = directParts[0].trim();
      }
    } else {
      if (parts.length > 0 && !(parts[0] || "").match(checkboxRegex) && (parts[0] || "").trim() !== "") {
        leadingText = parts[0].trim();
      }
    }

    // Reconstruct items by combining checkbox pattern with following text
    for (let i = 0; i < parts.length; i++) {
      if (parts[i] && parts[i].match(checkboxRegex)) {
        const checkboxPart = parts[i];
        const textPart = parts[i + 1] || "";
        // Extract text until next checkbox or end
        const nextCheckboxIndex = textPart.search(/\[[\sx]?\]/);
        let content = nextCheckboxIndex >= 0 ? textPart.substring(0, nextCheckboxIndex) : textPart;
        content = content.trim();
        items.push(`${checkboxPart} ${content}`.trim());
        if (nextCheckboxIndex >= 0) {
          parts[i + 1] = textPart.substring(nextCheckboxIndex);
        } else {
          i++; // Skip the next part as we've consumed it
        }
      }
    }
    
    // Fallback to original logic if no multiple checkboxes found
    if (items.length <= 1) {
      const fallbackItems = text.includes(this.settings.separator) ? text.split(this.settings.separator).map((item) => item.trim()) : [text.trim()];
      items.length = 0;
      items.push(...fallbackItems);
    }
*** End Patch